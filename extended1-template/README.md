# Number Series, Wrapper and Benchmark

In this assignment, you have to implement a data type (class) `number_series`, to store a number series (just a sequence of integers).

1. Implement `number_series` class using `std::vector<int>` as a member of the class.
   - Maintain the **minimum** and the **maximum** values of a number series as members of your class (so that you do not have to compute them when needed).
   - Implement the necessary *constructors/destructors/assignment operators*. Implement them only if the ones generated by default are not good. Study Section 17.6 or Item 17 in EMC++ to learn about what is generated by the compiler.
   - Your class should have a static factory function `make_random` that returns a random number series of a desired length. See Section 5.6.3, to learn how to generate random numbers.
   - Implement `operator+` and `operator+=` to add two number series element-wise. Decide yourself what to do if the number series have different lengths.
   - Implement `operator<` to compare the *amplitudes* of two number series. The amplitude is the difference between the *maximum* and the *minimum* values.
2. Write a short client program that:
   - Fills an array/vector of 100.000 random number series, each with 100 elements.
   - Adds a random number series to each of number series in the array/vector.
   - Sorts the array/vector according to the amplitudes of number series. 
   - Record how much time it takes to sort (remember, you recorded running time in Exercise 2 of Lecture 1). 
3. Write a wrapper class, that has just one private data member: `std::unique_ptr<number_series>`. Otherwise, all the interface is the same as for `number_series`. Think about the copy/move constructors/assignment operators, that you may need to provide or rely on the default ones. On the client side, demonstrate that you can now use essentially the same code as in step 2.
   - What do you expect regarding the performance of sorting objects of this wrapper class when compared to sorting the original `number_series` objects?
   - Measure the performance and see whether your expectations were confirmed.
4. For fun, just add `int averages[12];` as a data member of `number_series`.
   - Perform the time measurements again.
   - How did they change?

In your code, pay attention to use `const` whenever it makes sense (arguments, member functions). Pay attention to the correct use/not use of references/pointers/values. Compile without debug information for your time measurements.

## Unit Tests
[test_number_series.cpp](test_number_series.cpp) includes unit tests to guide you through the implementation.

## Benchmarks
[bm_sort.cpp](bm_sort.cpp) includes a sorting example demonstrating how to use Google Benchmark library.
[bm_number_series.cpp](bm_number_series.cpp) your code for benchmarking the `number_series` and `number_series_wrap`.

## Libraries included
- [doctest](https://github.com/doctest/doctest): unit test framework.
- [Google Benchmark](https://github.com/google/benchmark): microbenchmark support library.

CMake should fetch those libraries automatically during `cmake` reload, and the libraries should build automatically when building the project.